#include <rclcpp/rclcpp.hpp>
#include <memory>
#include <vector>
#include <thread>
#include <memory>
#include <functional>
#include <assert.h>
#include <mutex>
#include "InputStream/source_node.hpp"
#include "VideoServer/streamer_node.hpp"
#include "LDW/main_LaneDetectorSim.h"
#include "FCW/detector.hpp"
#include "Aux/adasdebugapplication.pb.h"
#include "Aux/zmq.hpp"
#include "Aux/zhelpers.hpp"
#include "std_msgs/msg/string.hpp"
#include "std_msgs/msg/int32.hpp"
#include <msg/source_parameters.hpp>
//#include "msg/parameters_source.hpp"
#include <chrono>
#include <cinttypes>
#include <cstdio>
#include <string>

using namespace LaneDetectorSim;
using namespace ADAS_Debug_Application;

static std::mutex android_msg_mutex;  // protects android message from race condition.

class ZMQ_Server {
public:
	ZMQ_Server(): ctx_(1), socket_(ctx_, ZMQ_REP)
    {}

    void run(const std::shared_ptr<Message>&  msg_android)
    {

     socket_.bind("tcp://*:5555");
            while (true)
            {
                //  Wait for next request from client
            	zmq::message_t request;
                socket_.recv (&request);
                std::string req = std::string(static_cast<char*>(request.data()), request.size());

                //{

                 //Synchronize the threads,  if the conf is not thread safe.
                //std::lock_guard<std::mutex> gaurd(MUTEX);

               try
               {
            	   {//protected against race condition
            		   std::lock_guard<std::mutex> lock(android_msg_mutex);
					if (msg_android->ParseFromArray(request.data(),request.size()))
					{

					     cout<<"======================================================"<<endl;
						 cout<< "Request received from the client. Message parsed!"<<endl;
						 cout<<"======================================================"<<endl<<endl;
					}


					else
					{
						cerr<<"======================================================"<<endl;
			            cerr<< "Request received but failed to parse MessageType."<<endl;
						cerr<<"======================================================"<<endl<<endl;
					}
            	   }

               }

              catch (std::exception &e)
               {
            	  std::cout << e.what() << std::endl;
               }

             //Send reply back to client
                 zmq::message_t reply (8);
                 memcpy (reply.data (), "Enforced", 8);
                 socket_.send (reply);
			}
        }

private:
    zmq::context_t ctx_;
    zmq::socket_t socket_;
};



class ADAS_CommandServer: public rclcpp::Node
{

public:

	ADAS_CommandServer (const std::string & output, const std::shared_ptr<Message>&  msg_android, const std::string & node_name = "Command_node") : Node(node_name, true), msg_android_(msg_android)

	{

		rmw_qos_profile_t custom_qos_profile = rmw_qos_profile_default;
		custom_qos_profile.depth = 7;

		// src_pub_ = this->create_publisher<adas_pipeline::msg::ParametersSource>(output, custom_qos_profile);
		 //std::weak_ptr<std::remove_pointer<decltype(src_pub_.get())>::type> src_captured_pub = src_pub_;

		 src_pub_ = this->create_publisher<std_msgs::msg::Int32>(output, custom_qos_profile);
		 std::weak_ptr<std::remove_pointer<decltype(src_pub_.get())>::type> src_captured_pub = src_pub_;


		 //ldw_pub_ = this->create_publisher<std_msgs::msg::Int32>(output, custom_qos_profile);
		  //std::weak_ptr<std::remove_pointer<decltype(ldw_pub_.get())>::type> ldw_captured_pub = ldw_pub_;

		 // fcw_pub_ = this->create_publisher<std_msgs::msg::Int32>(output, custom_qos_profile);
		  //std::weak_ptr<std::remove_pointer<decltype(fcw_pub_.get())>::type> fcw_captured_pub = fcw_pub_;


		 auto callback = [src_captured_pub, this]() -> void
	    {

			 std::lock_guard<std::mutex> lock(android_msg_mutex);


		       if (msg_android_->messagetype() == MessageType::PipeLine_Config)
		       {

		        Message::PipelineConfig config = msg_android_->pipeline_config();
		      //adas_pipeline::msg::ParametersSource::UniquePtr msg (new adas_pipeline::msg::ParametersSource());


		    	   auto pub_ptr = src_captured_pub.lock();
		    	   if (!pub_ptr)
		    	   return;

		    	    std_msgs::msg::Int32::UniquePtr msg(new std_msgs::msg::Int32());


		    	   if (config.state()== State::PAUSE)
		    	   {
		    	   //adas_pipeline::msg::ParametersSource::UniquePtr

		    	    //msg->inputmode=0;
		    	    //msg->paused=true;
		    	    //msg->device=0;
		    	    //msg->fps=10;
		    	    //msg->dir="No directory";

		    		   msg->data=300;

		    	    cout<<"Published message with value: "<<msg->data<<endl;
		    	    pub_ptr->publish(msg);

		    	   }

		    	   else
		    	   if (config.state()== State::PLAY)
		    	  		    	   {
		    	  		    	   //adas_pipeline::msg::ParametersSource::UniquePtr

		    	  		    	    //msg->inputmode=0;
		    	  		    	    //msg->paused=true;
		    	  		    	    //msg->device=0;
		    	  		    	    //msg->fps=10;
		    	  		    	    //msg->dir="No directory";

		    	  		    		   msg->data=300;

		    	  		    	    cout<<"Published message with value: "<<msg->data<<endl;
		    	  		    	    pub_ptr->publish(msg);

		    	  		    	   }



		       }

		       else

		    	   if  (msg_android_->messagetype() == MessageType::LDW_Config)
		       {

		    		  /* auto pub_ptr = ldw_captured_pub.lock();
		    		   if (!pub_ptr)
		    		   return;
		    		   */
		       }
		       else if  (msg_android_->messagetype() == MessageType::FCW_Config)
			  {

		    	   /*auto pub_ptr = fcw_captured_pub.lock();
		    	   if (!pub_ptr)
		    	   return;
		    	   */

			  }





	    };


		 timer_ = this->create_wall_timer(200_ms, callback);
	}


	virtual ~ADAS_CommandServer()
	  {
	    // Make sure to join the thread on shutdown.
	   /* if (thread_.joinable()) {
	      thread_.join();
	    }*/
	  }


private :

	const std::shared_ptr<Message>  msg_android_;
	//rclcpp::TimerBase::SharedPtr timer_;
	rclcpp::TimerBase::SharedPtr timer_;
	rclcpp::Publisher<std_msgs::msg::Int32>::SharedPtr src_pub_;
	rclcpp::Publisher<std_msgs::msg::Int32>::SharedPtr ldw_pub_;
	rclcpp::Publisher<std_msgs::msg::Int32>::SharedPtr fcw_pub_;

};



int main(int argc, char * argv[])
{


  rclcpp::init(argc, argv);

  rclcpp::executors::MultiThreadedExecutor mexecutor;

 ///////////////////////////////////////////////////////////////////////

/* Start A ZeroMQ REQ-REP Server to get requests from android device */


  const auto android_msg = make_shared<Message>();
  ZMQ_Server ADAS_ZMQ_Server;
  std::thread *   zmq_server_thread;
  zmq_server_thread = new std::thread(std::bind(&ZMQ_Server::run, &ADAS_ZMQ_Server, android_msg));




 /////////////////////////////////////////////////////////////////////////


				//Arguments args_LDW= Arguments(1,1,61,0.0,0.1);
				//Args args_FCW = Args();


bool Pipeline_spin_request = false;
bool printed= false;

while (1)

{

	if (Pipeline_spin_request)
	{




		/////////////////////////////////////////////////////////////////////////
					/* Add relevent elements to ADAS Pipeline  */
			auto source_node         		  =   std::make_shared<Source_ADAS>("image");
			auto ADAS_command_server 		  =   std::make_shared<ADAS_CommandServer>("ADAS_command", android_msg);
			auto streamer_node_with_source    =   std::make_shared<Streamer>("image", android_msg->pipeline_config().ip(), 5000);
			//auto streamer_node_with_FCW     =   std::make_shared<Streamer>("image", args_streamer );


	    ///////////////////////////////////////////////////////////////////////////
				    /* Configure Pipeline before execution */

			rclcpp::executors::SingleThreadedExecutor executor;

			Message::PipelineConfig config = android_msg->pipeline_config();

			if (config.stream()== Stream::LDW)
			{
					executor.add_node(source_node);
					executor.add_node(streamer_node_with_source);
				    executor.add_node(ADAS_command_server);
			}
			else if (config.stream()== Stream::FCW)
			{
				executor.add_node(source_node);
				//executor.add_node(streamer_node_with_FCW);
				executor.add_node(ADAS_command_server);
			}
			else
			{

				executor.add_node(source_node);
				executor.add_node(streamer_node_with_source);
				executor.add_node(ADAS_command_server);

			}

	////////////////////////////////////////////////////////////////////////



		cout<<"======================================================"<<endl;
		cout<< "              Spinning Started                       "<<endl;
		cout<<"======================================================"<<endl;
		cout<< "Exiting ROS Spinning.... "<<endl<<endl;




	   /*Spin the Pipeline until ROS shutdowns */
		 executor.spin();


		 cout<<"======================================================"<<endl;
		 cout<< "              Spinning Finished                 "<<endl;
		 cout<<"======================================================"<<endl;
		 cout<< "Exiting ROS Spinning.... "<<endl<<endl;

		 /* reset spin request */
		 Pipeline_spin_request = false;

	////////////////////////////////////////////////////////////////////////

	}



     if (! printed)
     {
	 cout<<"======================================================"<<endl;
	 cout<< "	   Initiate Pipeline from the Android Client"	   <<endl;
	 cout<<"======================================================"<<endl;
	 cout<< "waiting for request form client .... "<<endl<<endl;
	 printed = true;
     }

     {//protected against race condition

    	 std::lock_guard<std::mutex> lock(android_msg_mutex);
		  if (android_msg->messagetype()== MessageType::PipeLine_Config)
		  {
			  Message::PipelineConfig config = android_msg->pipeline_config();

			  if (config.state()== State::PLAY)
				  Pipeline_spin_request= true;
		  }
     }


}





/*

 //make them atomic
 bool playing=false, finished=false, stopped=true, paused=false;


 while (! finished)
 {

		if (android_msg->messagetype()== MessageType::CONFIG)
		{

	      Message::Config config = android_msg->config();
	      args_streamer.setIP(config.ip());



	      if (config.state()== State::PLAY && !playing)
	      {

			// Connect the nodes as a pipeline: camera_node -> lanedetect_node-> streamer_node
			 auto source_node = std::make_shared<Source_ADAS>(args_Source);
			 //auto lanedetect_node = std::make_shared<LaneDetectNode>("image", "lanedetect_image", args_LDW);
			//auto detector_node = std::make_shared<App>("image", "detector_image", args_FCW);
			 auto streamer_node =   std::make_shared<Streamer>("image", args_streamer );



            // camera_node->create_wall_timer(1231,)

			  mexecutor.add_node(source_node);
			  mexecutor.add_node(streamer_node);

			  //executor.add_node(camera_node);
			  //executor.add_node(lanedetect_node);
			  //executor.add_node(detector_node);
			 // executor.add_node(streamer_node);
			  playing=true;
			  mexecutor.spin();
			  //executor.spin_some();
			 //executor.spin_node_once(camera_node, std::chrono::milliseconds(0));
			 //executor.spin_node_once(streamer_node, std::chrono::milliseconds(0));
			  //std::thread execution_thread(spin_executor);
			  //execution_thread.join();
			  cout<<"Spinning";
	      }










		}
	else
	{
		//cout<<"Main_thread_has_IP<<"<<args_streamer.getIP()<<endl;

	}


 }


*/




/*while (! zmq_server_thread->joinable()){cout<<"NOT_Join_Able";}
 zmq_server_thread->join();
cout<<"Join_Able";
delete zmq_server_thread;*/


return 0;


 //rclcpp::Publisher<Config>::SharedPtr pub_;

}





